# Relatório de Implementação - Advanced Filter Parser

**Data:** 31-12-2025  
**Tarefa:** Corrigir e implementar lógica de filtros avançados em `src/middlewares/filter-parser.ts`.

## O que foi feito

### 1. Correção de Sintaxe e Estrutura

O arquivo `src/middlewares/filter-parser.ts` continha blocos de markdown e snippets de código comentados de forma incorreta no final do arquivo, o que causava erros de compilação. Todo o conteúdo não-TypeScript foi removido e a classe `AdvancedFilterParser` foi refatorada.

### 2. Implementação do AdvancedFilterParser (Recursivo)

A implementação original era baseada em um `split` simples que não suportava parênteses aninhados. Implementei uma lógica de parsing recursivo que:

- Detecta parênteses e trata o conteúdo como sub-expressões.
- Suporta precedência lógica (OR > AND > NOT).
- Normaliza múltiplos dialetos de filtros (SQL-like, RSQL, Custom DSL).
- Inferência automática de tipos (Number, Boolean, Null, String).

### 3. Decorator @Filter

Seguindo a regra de arquitetura do projeto (Rule 10), foi criado um decorator `@Filter` em `src/decorators/filter.ts`. Este decorator:

- Intercepta a requisição.
- Extrai o filtro da query string (chave configurável, padrão: `filter`).
- Processa o filtro e injeta o resultado (objeto de consulta MongoDB-style) em `req.query.where`.
- Integra-se com o sistema AON (Adaptive Observability Negotiation) para reportar correções automáticas efetuadas na lógica.

### 4. Tipagem Semântica Nominal

Conforme a Rule 11, foram definidos os tipos nominais `RawFilterString` e `MongoQuery`. Estes tipos foram centralizados em `src/types.ts` para garantir a consistência de tipos em todo o backend.

### 5. Suite de Testes

Foi criada uma suite de testes em `test/filter-parser.test.ts` utilizando o test runner nativo do Node.js, validando:

- Operadores de comparação.
- Lógica AND/OR/NOT/NOR.
- Parênteses aninhados profundos.
- Diferentes dialetos de entrada.
- Inferência de tipos.

## Por que foi feito

A implementação robusta de filtros é crucial para APIs modernas onde o front-end precisa de flexibilidade para buscar dados sem que o back-end precise implementar rotas específicas para cada combinação de filtros. O uso de decorators e tipos nominais segue o padrão de excelência técnica exigido para o projeto `@purecore`.

## Como testar

Para rodar os testes unitários:

```bash
wsl tsx test/filter-parser.test.ts
```

Ou usando o bun:

```bash
wsl bun test test/filter-parser.test.ts
```
